diff --git a/lib/plugin/pl_player/controller.dart b/lib/plugin/pl_player/controller.dart
--- a/lib/plugin/pl_player/controller.dart
+++ b/lib/plugin/pl_player/controller.dart
@@ -77,6 +77,32 @@ class PlPlayerController {
   final Rx<VideoFitType> _videoFit = Rx(VideoFitType.contain);
   late StreamSubscription<DataStatus> _dataListenerForVideoFit;
   late StreamSubscription<DataStatus> _dataListenerForEnterFullscreen;
+
+  // 两步全屏：先竖屏沉浸式全屏，再旋转到横屏
+  bool _portraitFsFirstStep = false;
+  VideoFitType? _fitBeforePortraitFs;
+
+  bool get _deviceIsPortrait {
+    final size = Get.mediaQuery.size;
+    return size.height >= size.width;
+  }
+
+  Future<void> _enterPortraitFullscreenStep() async {
+    // 仅隐藏状态栏，不改方向；临时改为 contain 以居中不裁切显示横屏视频
+    hideStatusBar();
+    _portraitFsFirstStep = true;
+    _fitBeforePortraitFs ??= _videoFit.value;
+    if (_videoFit.value != VideoFitType.contain) {
+      _videoFit.value = VideoFitType.contain;
+    }
+    if (!_isFullScreen.value) {
+      _isFullScreen.value = true;
+      updateSubtitleStyle();
+    }
+  }
+
+  void _clearPortraitFullscreenStep() {
+    if (_portraitFsFirstStep) {
+      _portraitFsFirstStep = false;
+      if (_fitBeforePortraitFs != null) {
+        _videoFit.value = _fitBeforePortraitFs!;
+        _fitBeforePortraitFs = null;
+      }
+    }
+  }
 
   /// 后台播放
   late final RxBool _continuePlayInBackground =
@@ -1070,14 +1096,38 @@ class PlPlayerController {
   // 全屏
   bool fsProcessing = false;
   Future<void> triggerFullScreen({
     bool status = true,
     bool inAppFullScreen = false,
     bool isManualFS = true,
     FullScreenMode? mode,
   }) async {
     if (isDesktopPip) return;
-    if (isFullScreen.value == status) return;
+
+    // 在“竖屏全屏第一步”里，如果收到“返回/退出”，直接退出到详情页（还原状态），不转横屏
+    if (!status && _portraitFsFirstStep && Utils.isMobile) {
+      showStatusBar();
+      _clearPortraitFullscreenStep();
+      toggleFullScreen(false);
+      return;
+    }
+
+    // 某些 UI 会重复传 status=true；若仍在第一步，则把它视为“第二次点击”，旋转到横屏
+    if (status && _portraitFsFirstStep && Utils.isMobile) {
+      await landscape();
+      _clearPortraitFullscreenStep();
+      _isFullScreen.value = true;
+      updateSubtitleStyle();
+      return;
+    }
+
+    if (isFullScreen.value == status) return;
 
     if (fsProcessing) {
       return;
     }
     fsProcessing = true;
 
     mode ??= this.mode;
     this.isManualFS = isManualFS;
     toggleFullScreen(status);
 
     if (status) {
       if (Utils.isMobile) {
         hideStatusBar();
+        // 两步全屏：设备竖屏 + 视频横向 => 先竖屏沉浸式全屏并居中显示
+        if (_deviceIsPortrait && !isVertical) {
+          await _enterPortraitFullscreenStep();
+          fsProcessing = false;
+          return;
+        }
         if (mode == FullScreenMode.none) {
           fsProcessing = false;
           return;
         }
         if (mode == FullScreenMode.gravity) {
           await fullAutoModeForceSensor();
           fsProcessing = false;
           return;
         }
         late final size = Get.mediaQuery.size;
         if ((mode == FullScreenMode.vertical ||
             (mode == FullScreenMode.auto && isVertical) ||
             (mode == FullScreenMode.ratio &&
                 (isVertical || size.height / size.width < kScreenRatio)))) {
           await verticalScreenForTwoSeconds();
         } else {
           await landscape();
         }
       } else {
         await enterDesktopFullscreen(inAppFullScreen: inAppFullScreen);
       }
     } else {
       if (Utils.isMobile) {
         showStatusBar();
+        _clearPortraitFullscreenStep();
         if (mode == FullScreenMode.none) {
           fsProcessing = false;
           return;
         }
         if (!horizontalScreen) {
           await verticalScreenForTwoSeconds();
         } else {
           await autoScreen();
         }
       } else {
         await exitDesktopFullscreen();
       }
     }
     fsProcessing = false;
   }